# 未完成或待定功能

## 通用函数封装

【已解决】

## “取消”与“不存在”状态的冗余

取消的订单被判定为“不存在”

例如：

```go
// 检查订单是否存在：
  if err := tx.Where("id = ?", orderID).First(&order).Error; err != nil {
   if errors.Is(err, gorm.ErrRecordNotFound) {
    tx.Rollback()
    return c.Status(404).JSON(fiber.Map{
     "error": fmt.Sprintf("订单 %d 不存在", orderID),
    })
   }
   tx.Rollback()
   return c.Status(500).JSON(fiber.Map{"error": "查询订单失败"})
  }
  // 检查订单归属权：
  if order.UserID != userID {
   tx.Rollback()
   return c.Status(403).JSON(fiber.Map{
    "error": fmt.Sprintf("订单 %d 无权操作", orderID),
   })
  }
  // 检查订单状态：
  if order.Status == "cancelled" {
   tx.Rollback()
   return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
    "error": fmt.Sprintf("订单 %d 已取消，不可重复操作", orderID),
   })
  }
```

干脆不会走“检查订单状态”这一分支，而是直接返回“订单不存在”

不会影响功能，只是会显得代码冗余

这样的问题可能在增删改查中均会出现

是否应当区分这两种状态有待商榷

## 错误处理中英文不一致 & 状态码使用数字或关键词的统一

## 声明式权限控制与 Casbin

## Mock 测试与依赖注入

## JWT 增强

### Token 刷新机制

当前 Token 有效期固定为 3 天，建议实现刷新 Token 逻辑（如 /refresh 端点），避免用户频繁登录。

### 黑名单管理

使用 Redis 缓存已注销的 Token，防止 JWT 在有效期内被滥用（当前注销仅标记用户为删除，但未处理 Token）。

### 实现方法

- **新增 Redis 工具类**  
  在 `utils/redis.go` 中初始化 Redis 连接，并封装黑名单操作函数：

  ```go
  package utils

  import (
      "context"
      "github.com/go-redis/redis/v8"
      "time"
  )

  var RedisClient *redis.Client
  var Ctx = context.Background()

  func InitRedis() {
      RedisClient = redis.NewClient(&redis.Options{
          Addr:     config.Get("REDIS_ADDR"),
          Password: config.Get("REDIS_PASSWORD"),
          DB:       0,
      })
  }

  func AddToBlacklist(token string, expiration time.Duration) error {
      return RedisClient.Set(Ctx, "jti:"+token, true, expiration).Err()
  }

  func IsTokenRevoked(token string) bool {
      exists, _ := RedisClient.Exists(Ctx, "jti:"+token).Result()
      return exists > 0
  }
  ```

- **修改注销逻辑**  
  在 `controllers/auth.go` 的 `Logout` 方法中，将 Token 加入黑名单：

  ```go
  func (ac *AuthController) Logout(c *fiber.Ctx) error {
      // ...原有注销逻辑...

      // 获取 Token 并加入黑名单
      token := c.Locals("user").(*jwt.Token)
      tokenString := token.Raw
      expiration := time.Until(token.Claims.(jwt.MapClaims)["exp"].(time.Time))
      utils.AddToBlacklist(tokenString, expiration)

      return c.JSON(fiber.Map{"message": "用户已注销"})
  }
  ```

- **新增黑名单校验中间件**  
  在 `middleware/jwt.go` 中添加中间件：

  ```go
  func CheckTokenRevoked() fiber.Handler {
      return func(c *fiber.Ctx) error {
          token := c.Locals("user").(*jwt.Token)
          if utils.IsTokenRevoked(token.Raw) {
              return c.Status(401).JSON(fiber.Map{"error": "Token 已失效"})
          }
          return c.Next()
      }
  }
  ```

- **路由层应用中间件**  
  在 `routes/api.go` 的认证路由组中追加中间件：

  ```go
  authenticated := app.Group("/api", jwtMiddleware, middleware.CheckTokenRevoked())
  ```

## 错误处理与日志

### 统一错误响应

全局错误处理器：在 Fiber 中注册自定义错误中间件，统一格式化错误响应，避免重复代码。

### 实现方法

- **新增全局错误中间件**  
  在 `middleware/error_handler.go` 中定义：

  ```go
  package middleware

  import "github.com/gofiber/fiber/v2"

  func ErrorHandler(c *fiber.Ctx) error {
      err := c.Next()
      if err != nil {
          // 捕获 Fiber 默认错误
          if e, ok := err.(*fiber.Error); ok {
              return c.Status(e.Code).JSON(fiber.Map{"error": e.Message})
          }
          // 其他未知错误
          return c.Status(500).JSON(fiber.Map{"error": "内部服务器错误"})
      }
      return nil
  }
  ```

- **注册中间件**  
  在 `main.go` 中 **最先** 注册该中间件（确保覆盖所有路由）：

  ```go
  app.Use(middleware.ErrorHandler)
  ```

- **删除控制器中的重复代码**  
  移除所有 `ErrorResponse` 调用，直接返回错误：

  ```go
  // 示例：修改前
  return ErrorResponse(c, 500, "内部错误")

  // 修改后
  return fiber.NewError(500, "内部错误")
  ```

### 结构化日志

使用 Zap 或 Logrus：替换 log 包为结构化日志库，支持日志级别、上下文和集中式日志收集（如 ELK）。

### 实现方法

- **集成 Zap 日志库**  
  在 `utils/logger.go` 中初始化结构化日志：

  ```go
  package utils

  import "go.uber.org/zap"

  var Logger *zap.Logger

  func InitLogger() {
      Logger, _ = zap.NewProduction()
      defer Logger.Sync()
  }
  ```

- **替换日志输出**  
  修改 `main.go` 的日志中间件：

  ```go
  app.Use(logger.New(logger.Config{
      Output: utils.Logger.Writer(), // 输出到 Zap
      Format: "${time} ${status} - ${method} ${path}\n",
  }))
  ```

- **关键业务添加日志**  
  在 `services/matching.go` 的撮合逻辑中记录详细日志：

  ```go
  func (e *MatchingEngine) executeTrade(...) error {
      utils.Logger.Info("撮合成交",
          zap.Uint("buy_order_id", buy.ID),
          zap.Uint("sell_order_id", sell.ID),
          zap.Int("quantity", qty),
      )
      // ...原有逻辑...
  }
  ```

## 数据库优化

## 撮合引擎并发

### 实现方法

- **协程池处理订单批次**  
  使用 `ants` 库限制并发数（修改 `services/matching.go`）：

  ```go
  import "github.com/panjf2000/ants/v2"

  func (e *MatchingEngine) Run(ctx context.Context) {
      pool, _ := ants.NewPool(10) // 限制 10 个并发
      defer pool.Release()

      for {
          select {
          case <-ticker.C:
              buyOrders, sellOrders := e.fetchOrders()
              // 提交任务到协程池
              pool.Submit(func() {
                  e.processBatch(buyOrders, sellOrders)
              })
          }
      }
  }
  ```

- **通道同步撮合结果**  
  使用通道传递撮合任务，确保顺序性：

  ```go
  func (e *MatchingEngine) Run(ctx context.Context) {
      taskChan := make(chan []models.LiveOrder, 100)
      defer close(taskChan)

      // 启动 10 个 Worker
      for i := 0; i < 10; i++ {
          go e.worker(taskChan)
      }

      for {
          select {
          case <-ticker.C:
              buyOrders, sellOrders := e.fetchOrders()
              taskChan <- buyOrders
              taskChan <- sellOrders
          }
      }
  }

  func (e *MatchingEngine) worker(taskChan <-chan []models.LiveOrder) {
      for {
          buyOrders := <-taskChan
          sellOrders := <-taskChan
          e.processBatch(buyOrders, sellOrders)
      }
  }
  ```

## 测试与质量保障

### 单元测试覆盖

Table-Driven Tests：为服务层和控制器编写测试用例，覆盖正常流程和边界条件。

### 集成测试

Testcontainers：使用 Docker 容器模拟数据库环境，确保测试与生产环境一致性。

## 配置管理

Viper 集成：替换 .env 为 Viper，支持多环境配置（如 config/dev.yaml, config/prod.yaml）。

## 部署优化

Dockerfile：容器化部署，确保环境一致性。

## 其他企业级并发场景

1. **数据库连接池**  
   在 `config/database.go` 中配置：

   ```go
   func InitDB() (*gorm.DB, error) {
       db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
           PrepareStmt: true, // 开启预编译
       })
       sqlDB, _ := db.DB()
       sqlDB.SetMaxOpenConns(100) // 最大连接数
       sqlDB.SetMaxIdleConns(20)  // 空闲连接数
       return db, err
   }
   ```

2. **异步审计日志**  
   在 `services/order_service.go` 中使用通道异步写入日志：

   ```go
   var auditLogChan = make(chan models.AuditLog, 1000)

   func init() {
       go func() {
           for logEntry := range auditLogChan {
               db.Create(&logEntry) // 异步落库
           }
       }()
   }

   func (s *OrderService) EmergencyCancelOrder(...) error {
       auditLogChan <- models.AuditLog{
           UserID:  traderID,
           Action:  "emergency_cancel",
           OrderID: orderID,
       }
       // ...原有逻辑...
   }
   ```

3. **缓存并发控制**  
   在 `utils/redis.go` 中使用 `SETNX` 实现分布式锁：

   ```go
   func AcquireLock(key string, ttl time.Duration) bool {
       return RedisClient.SetNX(Ctx, key, "locked", ttl).Val()
   }

   func ReleaseLock(key string) {
       RedisClient.Del(Ctx, key)
   }
   ```

## 敏感数据脱敏

## SQL 注入防护
