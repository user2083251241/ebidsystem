# 项目开发杂记

# 测试

> 引入 `logrus` 包

```bash
go get github.com/sirupsen/logrus
```

## 阶段测试

### **1. 当前成果验证**

从你的描述来看，**已实现以下功能**：

1. **用户注册接口**：成功通过 POST 请求创建用户。
2. **数据库集成**：
   - 用户信息（用户名、密码哈希、角色）正确存储。
   - 密码通过 bcrypt 安全哈希（`$2a$10$...` 格式）。
3. **服务稳定性**：接口响应正常（200 状态码），无崩溃或异常。

---

### **2. 下一步验证目标**

#### **(1) 用户登录与 JWT 生成**

- **测试接口**：`POST /api/login`
- **请求示例**：

  ```json
  {
    "username": "testuser",
    "password": "123456"
  }
  ```

- **预期结果**：
  - 返回有效的 JWT 令牌（需实现 JWT 生成逻辑）。
  - 日志中显示登录成功的记录。

#### **(2) 订单创建功能**

- **测试接口**：`POST /api/orders`
- **请求示例**：

  ```json
  {
    "symbol": "AAPL",
    "quantity": 100,
    "direction": "buy"
  }
  ```

- **预期结果**：
  - 订单记录写入 `orders` 表。
  - 返回订单详情（含 `order_id` 和 `status`）。

#### **(3) 订单查询功能**

- **测试接口**：`GET /api/orders`
- **预期结果**：
  - 返回当前用户的所有订单列表。
  - 包含刚创建的订单数据。

---

### **3. 需继续完成的核心功能**

#### **(1) 完善登录接口的 JWT 逻辑**

- **实现步骤**：
  1. 安装 JWT 库：

     ```bash
     go get github.com/golang-jwt/jwt/v5
     ```

  2. 在 `controllers/auth.go` 中生成令牌：

     ```go
     func Login(c *fiber.Ctx) error {
       // 验证用户名和密码
       var req LoginRequest
       if err := c.BodyParser(&req); err != nil {
         return c.Status(400).JSON(fiber.Map{"error": "Invalid request"})
       }

       var user models.User
       if err := db.Where("username = ?", req.Username).First(&user).Error; err != nil {
         return c.Status(401).JSON(fiber.Map{"error": "Invalid credentials"})
       }

       // 验证密码哈希
       if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)); err != nil {
         return c.Status(401).JSON(fiber.Map{"error": "Invalid credentials"})
       }

       // 生成 JWT
       token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
         "user_id": user.ID,
         "role":    user.Role,
         "exp":     time.Now().Add(time.Hour * 24).Unix(),
       })

       tokenString, err := token.SignedString([]byte(config.Get("JWT_SECRET")))
       if err != nil {
         return c.Status(500).JSON(fiber.Map{"error": "Failed to generate token"})
       }

       return c.JSON(fiber.Map{"token": tokenString})
     }
     ```

#### **(2) 添加订单接口的认证中间件**

- **实现步骤**：
  1. 在 `routes/api.go` 中替换基础认证为 JWT 中间件：

     ```go
     import (
       "github.com/gofiber/jwt/v3"
       "github.com/champNoob/ebidsystem/backend/config"
     )

     // JWT 中间件配置
     jwtMiddleware := jwtware.New(jwtware.Config{
       SigningKey: []byte(config.Get("JWT_SECRET")),
     })

     // 需要认证的路由组
     authenticated := app.Group("/api", jwtMiddleware)
     ```

#### **(3) 订单与用户关联**

- **修改订单创建逻辑**：
  从 JWT 中提取用户 ID，而非硬编码 `UserID: 1`：

  ```go
  func CreateOrder(c *fiber.Ctx) error {
    // 从 JWT 中获取用户 ID
    claims := c.Locals("user").(*jwt.Token).Claims.(jwt.MapClaims)
    userID := uint(claims["user_id"].(float64))

    // 创建订单
    order := models.Order{
      UserID:    userID,
      Symbol:    req.Symbol,
      Quantity:  req.Quantity,
      Direction: req.Direction,
      Status:    "pending",
    }
    // ...
  }
  ```

---

### **4. 安全性增强建议**

#### **(1) 输入校验**

- **注册接口**：
  - 检查用户名长度（如 3-20 字符）。
  - 验证角色字段仅允许 `client`/`sales`/`trader`。
- **订单接口**：
  - 检查 `quantity` 必须大于 0。
  - 验证 `symbol` 是否存在于 `stocks` 表。

#### **(2) 错误处理**

- 返回明确的错误代码和消息：

  ```go
  if req.Role != "client" && req.Role != "sales" && req.Role != "trader" {
    return c.Status(400).JSON(fiber.Map{
      "code":    "INVALID_ROLE",
      "message": "Role must be client, sales, or trader",
    })
  }
  ```

#### **(3) 日志记录**

- 记录关键操作（如用户注册、订单创建）：

  ```go
  log.Printf("User %s registered with role %s", user.Username, user.Role)
  ```

---

### **5. 测试计划**

#### **(1) 用户登录测试**

```bash
# 正确凭据
curl -X POST http://localhost:3000/api/login \
  -H "Content-Type: application/json" \
  -d '{"username": "testuser", "password": "123456"}'

# 错误密码
curl -X POST http://localhost:3000/api/login \
  -H "Content-Type: application/json" \
  -d '{"username": "testuser", "password": "wrong"}'
```

#### **(2) 订单创建测试**

```bash
# 使用有效 JWT
curl -X POST http://localhost:3000/api/orders \
  -H "Authorization: Bearer <JWT_TOKEN>" \
  -H "Content-Type: application/json" \
  -d '{"symbol": "AAPL", "quantity": 100, "direction": "buy"}'

# 未提供 JWT
curl -X POST http://localhost:3000/api/orders \
  -H "Content-Type: application/json" \
  -d '{"symbol": "AAPL", "quantity": 100, "direction": "buy"}'
```

#### **(3) 数据库一致性检查**

```sql
-- 检查 orders 表
SELECT * FROM orders WHERE user_id = 1;

-- 检查 stocks 表（如有）
SELECT * FROM stocks WHERE symbol = 'AAPL';
```

---

### **总结**

你已成功完成用户注册功能的开发与验证！接下来：

1. **实现 JWT 登录逻辑**：确保用户凭证安全。
2. **完善订单接口的认证与业务逻辑**：关联用户身份。
3. **添加输入校验与错误处理**：提升系统健壮性。

完成以上步骤后，你的后端将具备完整的用户-订单交互能力。后续可逐步扩展功能（如股票数据实时更新、交易撮合引擎）。

## 单元测试

### 自带函数

#### `TestMain`

`TestMain` 是 `go test` 命令的入口函数，用于设置测试环境、初始化测试数据等。

```go
func TestMain(m *testing.M) {
	os.Exit(m.Run())
}
```

#### `m.Run()`

`m.Run()` 是 Go 测试框架中的一个核心函数，它主要做以下几件事：

- 执行所有以 `Test` 开头的测试函数
- 执行所有以 `Benchmark` 开头的基准测试函数
- 收集并报告测试结果
- 返回一个退出码（0 表示所有测试通过，非 0 表示有测试失败）

# 数据库

## MySQL

### 登录

```bash
mysql -u root -p
```

### 数据库

#### 查看数据库

```sql
show databases;
```

#### 进入数据库

```sql
use database_name;
```

### 表

#### 查看表

```sql
show tables;
```

#### 创建表

```sql
CREATE TABLE table_name (
  column1 datatype constraint,
  column2 datatype constraint,
  column3 datatype constraint,
  ...
);
```

#### 删除表

```sql
DROP TABLE table_name;
```

#### 修改表

```sql
ALTER TABLE table_name
ADD column_name datatype constraint;
```

#### 查看表结构

```sql
DESCRIBE table_name;
```

### 数据

#### 查看数据

```sql
SELECT * FROM table_name WHERE condition;
```

#### 插入数据

```sql
INSERT INTO table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);
```

#### 更新数据

```sql
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
```

#### 删除数据

```sql
DELETE FROM table_name
WHERE condition;
```

# 包

## 包版本冲突和中间件不兼容

### 遇到的问题

- `JWT` 包版本冲突：代码中混用了不同版本的 `JWT` 包（如 `jwt/v3` 和 `jwt/v5`），导致类型断言失败（i`nterface conversion` 错误）。

- `Fiber` 中间件兼容性：`Fiber` 的 `JWT` 中间件未正确适配 `jwt/v5`，引发编译错误（`undefined: jwt`）

### 解决步骤

1. 统一 `JWT` 版本

  所有代码中导入 `github.com/golang-jwt/jwt/v5`

  更新 `Fiber` 中间件至兼容版本（`github.com/gofiber/contrib/jwt`）

2. 修正中间件初始化

  使用新版中间件别名 jwtware，并调整配置语法。

3. 清理依赖

  ```bash
  go get -u github.com/gofiber/contrib/ jwt@latest
  go mod tidy
  go clean -modcache
  ```

4. 更新 Token 解析逻辑

  确保从上下文中提取的 Token 类型与生成时一致。

## 导包路径宏替换

### 短期

```go
module github.com/user2083251241/ebidsystem  // 确保模块名与远程仓库一致

go 1.21  // 你的 Go 版本

// 添加以下替换规则
replace github.com/champNoob/ebidsystem/backend => ./
```

### 长期

```bash
go mod edit -replace=github.com/champNoob/ebidsystem/backend=github.com/user2083251241/ebidsystem/backendDev
go mod tidy
```

# 代码规范

## `RESTful` 规范化实践

### 核心原则

- 资源导向：通过 URL 路径表示资源（如 /orders 表示订单集合）。

- HTTP 方法明确语义：

  GET：查询资源

  POST：创建资源

  PUT：更新资源

  DELETE：删除资源

- 状态码标准化：如 200（成功）、404（资源不存在）、403（无权限）

- 无状态性：每个请求应包含完成操作所需的全部信息

### 优点

- 可读性高：API 路径和操作意图一目了然（如 GET /seller/orders 表示获取卖家订单）

- 扩展性强：资源分层清晰，便于后续新增功能

- 跨平台兼容：符合通用标准，便于前后端协作

## 复用

不同身份用户的很多 CURD 操作是基本相同的。因此考虑将这些**通用操作封装成函数**，通过参数传递来区分不同身份用户

【话术】

### 鉴权中间件复用

在 `./middleware/auth.go` 中，存在 `SellerOnly`、`SalesOnly`、`TraderOnly`、`ClientInly` 等鉴权函数。这些函数的内容有大一部分的重复

可以使用 `RoleRequired(role string)` 函数，将不同的身份以字符串参数的形式传递，用同一函数鉴权不同的身份

### 订单操作复用 + 权限优化

## `SOLID` 原则

### `SRP`

### `OCP`

### `LSP`

### `ISP`

### `DIP`

## 命名规范

### 驼峰 + 蛇形

变量名和函数名通常使用驼峰命名法（`camelCase`），而常量和包名则使用蛇形命名法（`snake_case`）

### 

# 安全

## 事务一致性

本项目的软删除 `Delete()` 和状态更新 `Update()` 必须在同一个事务中执行，否则会导致数据不一致

因此引入了 `gorm` 的 `Transaction()` 方法（即事务机制），确保在事务中执行删除和更新操作，从而保证数据的一致性

## `JWT`

JWT 即 JSON Web Token，是一种用于在网络应用间安全传递声明的开放标准（RFC 7519）。下面从定义、结构、工作原理、优缺点和应用场景等方面详细介绍：

### 定义

JWT 是一种紧凑且自包含的方式，用于在各方之间以 JSON 对象的形式安全地传输信息。此信息可以被验证和信任，因为它是经过数字签名的。JWT 可以使用密钥（使用 HMAC 算法）或使用 RSA 或 ECDSA 的公钥/私钥对进行签名。

### 结构

> `header` + `payload` + `signature`

#### 1. `Header`（头部）

包含两部分信息：声明类型（`typ`）和声明算法（`alg`）

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

然后，这个 JSON 对象会使用 Base64Url 编码形成 JWT 的第一部分。

#### 2. `Payload`（负载）

包含声明（`Claims`），声明是关于实体（通常是用户）和其他数据的声明。声明有三种类型：注册声明、公开声明和私有声明

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
```

#### 3. `Signature`（签名）

对 `Header` 和 `Payload` 进行签名，用于验证消息在传递过程中没有被更改，并且在使用私钥签名的情况下，还可以验证 JWT 的发送者的身份。

例如，如果使用的是 HMAC SHA256 算法，签名将按以下方式创建：

```plaintext
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

同样，这个 JSON 对象会使用 Base64Url 编码形成 JWT 的第二部分。

### 工作原理

1. **用户登录**：用户向服务器发送登录请求，提供用户名和密码。
2. **服务器验证**：服务器验证用户的凭证，如果验证通过，服务器会根据用户信息和预设的规则生成一个 JWT。
3. **返回 JWT**：服务器将生成的 JWT 返回给客户端。
4. **客户端存储和使用**：客户端接收到 JWT 后，通常会将其存储在本地（如 localStorage 或 cookie）。在后续的请求中，客户端会在请求头中包含这个 JWT，通常使用 `Authorization` 字段，格式为 `Bearer <JWT>`。
5. **服务器验证 JWT**：服务器接收到请求后，会从请求头中提取 JWT，并验证其签名和有效性。如果验证通过，服务器会根据 JWT 中的信息处理请求并返回响应。

### 优缺点

#### 优点

- **无状态**：JWT 是无状态的，服务器不需要存储会话信息，这使得它非常适合用于分布式系统和微服务架构。
- **跨域支持**：由于 JWT 可以通过 HTTP 请求头传递，因此可以轻松地跨域使用。
- **可扩展性**：JWT 的 Payload 部分可以包含任意信息，因此可以根据需要扩展其功能。

#### 缺点

- **安全性问题**：如果 JWT 的秘钥泄露，攻击者可以伪造 JWT 并进行恶意操作。此外，由于 JWT 通常存储在客户端，可能会受到 XSS 和 CSRF 攻击。
- **Payload 可被解码**：虽然 Payload 是经过 Base64Url 编码的，但这并不是加密，任何人都可以解码 Payload 中的信息，因此不应该在 Payload 中包含敏感信息。

### 应用场景

- **身份验证**：在用户登录后，服务器返回一个 JWT 给客户端，客户端在后续的请求中携带这个 JWT 进行身份验证。
- **信息交换**：JWT 可以在不同的服务之间安全地传递信息，例如在微服务架构中，不同的服务可以通过 JWT 来验证和交换用户信息。

### 示例

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
```

### JWT 的签名机制如何保证其内容不被篡改？

JWT 的签名机制通过以下步骤确保数据完整性：

1. 生成签名

使用密钥（如 `JWT_SECRET`）对 Header（算法类型）和 Payload（用户数据）进行哈希（如 HMAC SHA256），生成签名。

公式：`签名 = HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)`

2. 验证签名

服务端收到 `JWT` 后，用相同密钥重新计算签名，若与 `JWT` 中的签名不一致，则判定数据被篡改。

- 示例：用户登录时生成 `Token`

```go
token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
    "user_id": 123,
    "role":    "seller",
    "exp":     time.Now().Add(72 * time.Hour).Unix(),
})
tokenString, _ := token.SignedString([]byte("your_secret_key"))
```

攻击者篡改 Payload 中的 role 为 admin 后，服务端验证签名失败，拒绝请求

## 鉴权中间件

位置：./middleware/auth.go

# 规模（高并发）

## 多数据库（跨数据库）怎么办？

数据库中间件（如数据库代理）/分布式事务管理/数据复制和同步/服务层聚合/API 网关/跨数据库 ORM 支持

【话术】项目->买卖两种订单可能需要多表储存（考虑到撮合机制，但最终因为多表的索引慢、事务管理一致性问题）->如果是多数据库，那问题只会更大->查询资料+询问ai->得出结论/增长知识

# Redis

## 端口占用问题

查看：

```bash
PS C:\WINDOWS\system32> netstat -ano | findstr "6379"
  TCP    127.0.0.1:6379         0.0.0.0:0              LISTENING       5600
```

解决：

```bash
taskkill /PID 5600 /F
```

# 整体反思

## “习以为常”的功能

### 注册后还需登录的底层原因

【话术】后端（数据库）保存了用户信息，却不会返回 `JWT`。只有转而进行登录操作，请求登录接口，后端才会返回 `JWT`

# 其他

## 信息传递方式对比（上下文/函数）

### 通过上下文（Fiber 的 c.Locals）

优点：天然支持请求级别隔离，无需手动传递。

缺点：隐式依赖，需约定 Key 名称。

```go
// 中间件设置
c.Locals("currentUser", user)

// 控制器获取
user := c.Locals("currentUser").(*models.User)
```

### 通过函数参数传递

优点：显式依赖，易于理解。

缺点：需修改所有控制器函数签名。

go
func UpdateOrder(c *fiber.Ctx, user *models.User) error { ... }
全局变量（不推荐）：

缺点：并发不安全，难以测试。

### 方案选择

上下文：适合跨中间件、控制器传递数据（如用户信息）

函数参数：适合局部明确依赖的场景（如服务方法）

## xxx
