# 未完成或待定功能

## 通用函数封装

订单的增删改查对于seller和client在一定程度上是重复的

```go
func CreateOrder(c *fiber.Ctx, allowedRole, direction string) error {
    // 校验角色
    if c.Locals("role") != allowedRole {
        return c.Status(fiber.StatusForbidden).JSON(fiber.Map{"error": "无权限"})
    }
    // 校验方向
    if direction != "buy" && direction != "sell" {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "无效方向"})
    }
    // 通用创建逻辑...
    return nil
}
```

## “取消”与“不存在”状态的冗余

取消的订单被判定为“不存在”

例如：

```go
// 检查订单是否存在：
		if err := tx.Where("id = ?", orderID).First(&order).Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				tx.Rollback()
				return c.Status(404).JSON(fiber.Map{
					"error": fmt.Sprintf("订单 %d 不存在", orderID),
				})
			}
			tx.Rollback()
			return c.Status(500).JSON(fiber.Map{"error": "查询订单失败"})
		}
		// 检查订单归属权：
		if order.UserID != userID {
			tx.Rollback()
			return c.Status(403).JSON(fiber.Map{
				"error": fmt.Sprintf("订单 %d 无权操作", orderID),
			})
		}
		// 检查订单状态：
		if order.Status == "cancelled" {
			tx.Rollback()
			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
				"error": fmt.Sprintf("订单 %d 已取消，不可重复操作", orderID),
			})
		}
```

干脆不会走“检查订单状态”这一分支，而是直接返回“订单不存在”

不会影响功能，只是会显得代码冗余

这样的问题可能在增删改查中均会出现

是否应当区分这两种状态有待商榷

## 错误处理中英文不一致
